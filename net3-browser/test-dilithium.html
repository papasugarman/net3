<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Test page">
    <title>Test Page</title>
</head>
<body>
<script src="./dilithium.js"></script>
    <header>
        <h1>Test Page</h1>
    </header>

    <main>
        <section>
            <h2>Welcome</h2>
            <p>This is a test page with basic HTML5 structure.</p>
        </section>
    </main>

    <footer>
        <p>&copy; 2025</p>
    </footer>
</body>
</html>
<script>
    (async () => {
//async function main() {
var dilithiumModule;
async function init(){
  // Fetch the WASM binary
  const wasmBuffer = await (await fetch("./dilithium.wasm")).arrayBuffer();

  // Initialize Dilithium with the WASM binary
   dilithiumModule = await dilithium({
    wasmBinary: wasmBuffer,
    locateFile: (path) => "./" + path
  });
}

  const DILITHIUM_PARAMS = [
    { CRYPTO_PUBLICKEYBYTES: 896, CRYPTO_SECRETKEYBYTES: 2096, CRYPTO_BYTES: 1387 },
    { CRYPTO_PUBLICKEYBYTES: 1184, CRYPTO_SECRETKEYBYTES: 2800, CRYPTO_BYTES: 2044 },
    { CRYPTO_PUBLICKEYBYTES: 1472, CRYPTO_SECRETKEYBYTES: 3504, CRYPTO_BYTES: 2701 },
    { CRYPTO_PUBLICKEYBYTES: 1760, CRYPTO_SECRETKEYBYTES: 3856, CRYPTO_BYTES: 3366 }
  ];

  // Helper function to generate keys
  function generateKeys(kind, seed) {
    if (kind < 0 || kind > 3) {
      return -1;
    }

    const seedSize = seed ? seed.length : 0;
    const seedPtr = seed ? dilithiumModule._malloc(seedSize) : 0;
    if (seed) {
      dilithiumModule.HEAPU8.set(new Uint8Array(seed), seedPtr);
    }

    const privateKeySize = DILITHIUM_PARAMS[kind].CRYPTO_SECRETKEYBYTES;
    const publicKeySize = DILITHIUM_PARAMS[kind].CRYPTO_PUBLICKEYBYTES;

    const publicKeyPtr = dilithiumModule._malloc(publicKeySize);
    const privateKeyPtr = dilithiumModule._malloc(privateKeySize);

    const result = dilithiumModule.ccall(
      "dilithium_keygen",
      "number",
      ["number", "number", "number", "number", "number"],
      [publicKeyPtr, privateKeyPtr, kind, seedPtr, seedSize]
    );

    let publicKey, privateKey;
    if (result === 0) {
      publicKey = new Uint8Array(
        dilithiumModule.HEAPU8.subarray(publicKeyPtr, publicKeyPtr + publicKeySize)
      );
      privateKey = new Uint8Array(
        dilithiumModule.HEAPU8.subarray(privateKeyPtr, privateKeyPtr + privateKeySize)
      );
    }

    if (seedPtr) dilithiumModule._free(seedPtr);
    dilithiumModule._free(publicKeyPtr);
    dilithiumModule._free(privateKeyPtr);

    return { result, publicKey, privateKey };
  }

  // Helper function to sign
  function sign(message, privateKey, kind) {
    if (kind < 0 || kind > 3) {
      throw new Error("Invalid Dilithium kind");
    }

    const params = DILITHIUM_PARAMS[kind];
    const cryptoBytes = params.CRYPTO_BYTES;

    const messageLength = message.length;
    const messagePtr = dilithiumModule._malloc(messageLength);
    dilithiumModule.HEAPU8.set(new Uint8Array(message), messagePtr);

    const privateKeySize = privateKey.length;
    if (privateKeySize !== params.CRYPTO_SECRETKEYBYTES) {
      throw new Error(
        `Invalid private key size. Expected: ${params.CRYPTO_SECRETKEYBYTES}, Provided: ${privateKeySize}`
      );
    }
    const privateKeyPtr = dilithiumModule._malloc(privateKeySize);
    dilithiumModule.HEAPU8.set(new Uint8Array(privateKey), privateKeyPtr);

    const maxSignatureLength = cryptoBytes + messageLength;
    const signaturePtr = dilithiumModule._malloc(maxSignatureLength);
    const signatureLengthPtr = dilithiumModule._malloc(4);
    dilithiumModule.setValue(signatureLengthPtr, maxSignatureLength, "i32");

    const result = dilithiumModule.ccall(
      "dilithium_sign",
      "number",
      ["number", "number", "number", "number", "number", "number", "number"],
      [signaturePtr, signatureLengthPtr, messagePtr, messageLength, privateKeyPtr, privateKeySize, kind]
    );

    const actualSignatureLength = dilithiumModule.getValue(signatureLengthPtr, "i32");
    const signatureData = new Uint8Array(
      dilithiumModule.HEAPU8.buffer,
      signaturePtr,
      actualSignatureLength
    );
    const signature = new Uint8Array(signatureData);

    dilithiumModule._free(messagePtr);
    dilithiumModule._free(privateKeyPtr);
    dilithiumModule._free(signaturePtr);
    dilithiumModule._free(signatureLengthPtr);

    return { result, signature, signatureLength: actualSignatureLength };
  }

  // Helper function to verify
  function verify(signature, message, publicKey, kind) {
    const params = DILITHIUM_PARAMS[kind];
    const expectedSignatureSize = params.CRYPTO_BYTES + message.length;
    const expectedPublicKeySize = params.CRYPTO_PUBLICKEYBYTES;

    if (signature.length !== expectedSignatureSize) {
      throw new Error(
        `Invalid signature size. Expected ${expectedSignatureSize}, got ${signature.length}`
      );
    }
    if (publicKey.length !== expectedPublicKeySize) {
      throw new Error(
        `Invalid public key size. Expected ${expectedPublicKeySize}, got ${publicKey.length}`
      );
    }

    const signaturePtr = dilithiumModule._malloc(expectedSignatureSize);
    const messagePtr = dilithiumModule._malloc(message.length);
    const publicKeyPtr = dilithiumModule._malloc(expectedPublicKeySize);

    dilithiumModule.HEAPU8.set(new Uint8Array(signature), signaturePtr);
    dilithiumModule.HEAPU8.set(new Uint8Array(message), messagePtr);
    dilithiumModule.HEAPU8.set(new Uint8Array(publicKey), publicKeyPtr);

    try {
      const result = dilithiumModule.ccall(
        "dilithium_verify",
        "number",
        ["number", "number", "number", "bigint", "number", "number", "number"],
        [signaturePtr, expectedSignatureSize, messagePtr, BigInt(message.length), publicKeyPtr, expectedPublicKeySize, kind]
      );

      return {
        result,
        signatureLength: signature.length,
        expectedSignatureSize,
        messageLength: message.length,
        publicKeyLength: publicKey.length,
        expectedPublicKeySize,
        kind
      };
    } finally {
      dilithiumModule._free(signaturePtr);
      dilithiumModule._free(messagePtr);
      dilithiumModule._free(publicKeyPtr);
    }
  }

  await init();
  console.log("Dilithium initialized");

  // Generate keys (kind is 0-indexed: 0=Dilithium2, 1=Dilithium3, 2=Dilithium5)
  const kind = 2; // Dilithium5
  const keyResult = generateKeys(kind);
  if (keyResult.result !== 0) {
    throw new Error("Key generation failed");
  }
  const { publicKey, privateKey } = keyResult;
  console.log("Keys generated:", { publicKey: publicKey.length, privateKey: privateKey.length });

  // Sign a message
  const message = new TextEncoder().encode("Hello, Dilithium!");
  const signResult = sign(message, privateKey, kind);
  console.log("Message signed:", signResult.signature.length);

  // Verify the signature
  const verificationResult = verify(signResult.signature, message, publicKey, kind);
  console.log("Verification result:", verificationResult.result === 0 ? "Valid" : "Invalid");
//}

//main().catch(console.error);
})();
</script>